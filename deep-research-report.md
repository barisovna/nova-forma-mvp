# План выполнения задания: расширение AishaDietBot в кроссплатформенное геймифицированное приложение

Дата: 2026-02-15

## 1. Что фиксируем из задания

1. Базовая стратегия: не клонировать бота в каждый канал, а сделать единое серверное ядро и подключать к нему каналы (Web/PWA, mobile, мессенджеры).
2. Приоритет запуска: сначала Web/PWA MVP, затем iOS/Android, затем внешние мессенджеры как каналы привлечения и удержания.
3. Геймификация должна жить на сервере: streaks, достижения, квесты, лидерборды, прогресс.
4. Монетизация и права доступа должны быть централизованы: entitlements на сервере, независимо от канала покупки.
5. Нужно учитывать ограничения каналов (например, окна сообщений у WhatsApp/Meta) и требования по приватности данных.

## 2. Целевой результат проекта

1. Пользователь может:
- пройти онбординг;
- получить персональный план питания;
- логировать питание и прогресс;
- получать очки/достижения/streak;
- получать напоминания;
- оформить подписку.
2. Все это работает из Web/PWA как основного интерфейса и масштабируется на mobile/мессенджеры без переписывания логики.

## 3. GitHub и Vercel: правильная схема

1. GitHub хранит код, CI/CD и историю изменений.
2. Vercel хостит фронтенд и serverless-часть (если используется) + окружения (`Preview`, `Production`).
3. API-ключи не должны храниться в репозитории и не должны коммититься в `.vercel`.
4. `.vercel/` держим только локально (в `.gitignore`), а секреты храним через Vercel Environment Variables и GitHub Secrets.

## 4. Ключи и секреты (DeepSeek, Qwen и другие)

1. В Vercel завести переменные:
- `DEEPSEEK_API_KEY`
- `QWEN_API_KEY`
- `DATABASE_URL`
- `REDIS_URL`
- `JWT_SECRET`
- `WEB_PUSH_PUBLIC_KEY`
- `WEB_PUSH_PRIVATE_KEY`
- `PAYMENT_SECRET_KEY`
- `TELEGRAM_BOT_TOKEN` (если нужен мост с текущим ботом)
2. Локально использовать `.env.local`, который не коммитится.
3. Добавить в репозиторий проверки утечки секретов (gitleaks/trufflehog в CI).
4. Провести ротацию ключей, если раньше они уже попадали в файлы/коммиты.

## 5. Архитектура реализации

1. `Core API`:
- профили и цели;
- план питания и адаптация рецептов;
- трекер прогресса;
- геймификация;
- подписки и права доступа.
2. `LLM Gateway`:
- единый интерфейс к DeepSeek/Qwen (и fallback-провайдер);
- лимиты, ретраи, логирование ошибок, контроль стоимости.
3. `Notification Service`:
- web push для PWA;
- планировщик напоминаний;
- в будущем APNs/FCM для mobile.
4. `Channel Adapters`:
- Web/PWA (первый канал);
- Telegram bridge (минимум);
- далее WhatsApp/Instagram/Messenger/VK по приоритету.

## 6. План выполнения по этапам

### Этап 0. Подготовка (1 неделя)

1. Зафиксировать scope MVP и Definition of Done.
2. Создать/привести в порядок GitHub-репозиторий:
- `main`, `dev`, protection rules, PR template, issue template.
3. Подключить проект к Vercel (`Preview` + `Production`).
4. Настроить базовый CI:
- lint;
- unit tests;
- build;
- secret scan.
5. Подготовить таблицу env-переменных и владельцев.

Результат этапа: есть безопасная инфраструктура поставки и окружения.

### Этап 1. Серверное ядро MVP (2-3 недели)

1. Реализовать доменные модули:
- `users`;
- `nutrition_plan`;
- `progress`;
- `gamification`;
- `billing`.
2. Добавить `LLM Gateway` с переключением провайдера:
- `LLM_PROVIDER=deepseek|qwen`;
- общий контракт ответа.
3. Реализовать логирование событий:
- `onboarding_completed`;
- `plan_generated`;
- `meal_logged`;
- `streak_extended`.
4. Добавить rate limiting и базовую антифрод-логику.

Результат этапа: единый backend с API, который не зависит от конкретного канала.

### Этап 2. Web/PWA клиент (2-3 недели)

1. Экран онбординга и расчет стартового плана.
2. Дневник питания и прогресса.
3. Базовая геймификация:
- streak;
- 5-10 достижений;
- недельная цель.
4. Service Worker и web push.
5. Личный кабинет подписки.

Результат этапа: рабочий кроссплатформенный MVP с главным пользовательским сценарием.

### Этап 3. Монетизация и аналитика (1-2 недели)

1. Подключить платежного провайдера и серверную проверку статусов оплаты.
2. Реализовать entitlements (free/trial/premium).
3. Настроить продуктовые дашборды:
- activation;
- D1/D7 retention;
- trial-to-paid;
- ARPPU;
- churn.

Результат этапа: измеряемый MVP с контролируемой монетизацией.

### Этап 4. Каналы привлечения (2-4 недели)

1. Telegram bridge: deep link в web и синхронизация пользователя.
2. WhatsApp/Instagram/Messenger: только минимальные сценарии (онбординг, напоминания, возврат в web/app).
3. В сообщениях вне окна использовать только разрешенные шаблоны и opt-in механику.

Результат этапа: новые каналы приводят трафик, а core-продукт остается единым.

### Этап 5. Mobile масштабирование (после product-market fit)

1. Запустить iOS/Android клиент на том же API.
2. Подключить APNs/FCM и мобильные purchase-flows.
3. Синхронизировать подписки и прогресс с web.

Результат этапа: усиление retention и LTV через нативный канал.

## 7. Контрольные метрики по неделям

1. Activation: доля пользователей, дошедших до первого плана.
2. Time-to-value: минуты до первого полезного результата.
3. Engagement: доля пользователей с 3+ логами в неделю.
4. Retention: D1, D7, D30.
5. Monetization: trial-to-paid, MRR, churn.
6. Reliability: error rate API, latency, доля успешных push.

## 8. Риски и как их закрыть

1. Утечка ключей:
- запрет коммитов `.env*`;
- secret scan в CI;
- регулярная ротация.
2. Рост стоимости LLM:
- лимиты запросов;
- кэширование;
- fallback и деградация без блокировки продукта.
3. Низкий retention:
- быстрый first value;
- понятные ежедневные механики;
- A/B тесты геймификации.
4. Юридические риски:
- минимизация данных;
- прозрачное согласие;
- политика хранения и удаления.

## 9. Что сделать прямо сейчас (первые 48 часов)

1. Проверить, что в репозитории нет секретов и старых `.env` с ключами.
2. Подключить GitHub к Vercel и поднять Preview Deployments.
3. Завести env-переменные в Vercel для `Preview` и `Production`.
4. Зафиксировать MVP scope в issues и разбить работу на спринт 1.
5. Реализовать skeleton backend + healthcheck + первый endpoint генерации плана через `LLM Gateway`.

---

Этот план полностью совместим с вашей связкой GitHub + Vercel и учитывает работу с ключами DeepSeek/Qwen через безопасные env-переменные, без хранения секретов в коде.
